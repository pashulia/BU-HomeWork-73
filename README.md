# BU-HomeWork-73

Документация:
https://eips.ethereum.org/EIPS/eip-191

Пригодятся методы и функции отсюда
https://docs.ethers.org/v5/api/signer/#Signer--signing-methods
https://docs.ethers.org/v5/api/utils/bytes/#utils-arrayify
https://docs.ethers.org/v5/api/utils/bytes/#byte-manipulation--signature-conversion
https://docs.ethers.org/v5/api/utils/hashing/#utils-solidityPack

https://docs.soliditylang.org/en/latest/units-and-global-variables.html#mathematical-and-cryptographic-functions


Задание

Напишите один контракт Multisig, который будет верифицировать подписи созданные оффчейн и выполнять низкоуровневый вызов, в случае успешной верификации

Контракт Multisig должен содержать следующие функции:

construtor(address[] admins)
admins - список администраторов контракта

verify(uint256 nonce, address target, bytes payload, uint8[] v, bytes32[] r, bytes32[] s)
nonce - уникальный счётчик сообщений
target - адрес целевого контракта на который будет совершаться вызов
payload - полезная нагрузка для НУ вызова
v, r, s - массивы с соответствующими частями подписей

В своей реализации вы можете изменить некоторые параметры, здесь даны рекомендации
Также вы можете использовать дополнительные функции, например функцию для перевода числа в байтовый вид из библиотеки OP (смотри в презентации)

В контракте необходимо собрать сообщение из исходных данных, в которое как минимум входят nonce, target и payload 
Затем сделать дайджест, добавив к message добавить к нему префикс
"\x19Ethereum Signed Message:\n" + message.length
Здесь то и понадобиться перевод из числа в байтовый вид
Получить хеш из собранного дайджеста

Используя полученный хеш и подписи необходимо восстановить адреса тех, кто подписывал это сообщение офф-чейн

Далее проверить сколько администраторов контракта среди подписантов
Если более половины администраторов подписали сообщение - сделать низкоуровневый вызов на контракт Target

Учтите тот факт, что один администратор может подписать сообщение несколько раз - в таком случае необходимо учитывать только одну подпись

Также напишите контракт Target на который будет совершаться вызов.
Рекомендуется сделать в нём одну простую функцию вроде setNumber(uint256)
Но выполнить эту функцию может только owner контракта
В конструкторе в качестве owner необходимо установить адрес контракта Multisig 

Также напишите сркипт, в котором:
	•	деплоятся оба контракта
	•	при этом в контракт Multisig в качестве аргументов конструктора передаётся несколько адресов
	•	а в контракт Target в конструктор передаётся адрес Multisig 
	•	офф-чейн собирается сообщение для НУ вызова на Target
	•	сообщение подписывается несколькими админами
	•	на Multisig совершается вызов функции verify(), в которую передаются исходные данные из которых было собрано сообщение
	•	проверяется, что на Target успешно сработал вызов функции
